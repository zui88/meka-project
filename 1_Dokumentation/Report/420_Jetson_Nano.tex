\chapter{Jetson Nano}

In diesem Kapitel wird die Jetson Nano Hardware vorgestellt, weiterhin die
Einrichtung der Hardware und die Ordenerstruktur --- wo das Netzwerk und die
Anwendungsprogramme liegen.

Es folgt:
\begin{itemize}
  \item \"Ubersicht Jetson Nano
  \item Installation der n\"otigen Abh\"angigkeiten
  \item Ordnerstruktur der Projektdateien
\end{itemize}

Die Hauptinformationsquelle seitens der Hardware ist Hersteller
selbst~\cite{nvidia} und~\cite{nvidiaJetson}.




\section{Overview Jetson Nano}

% Hardwarebeschreibung Jetson Nano
Einen \"Uberblick der Hardware ist in \autoref{fig:Jet_Schema} zu sehen. Der
Jetson besteht aus einen Developement-Board --- Eine Hardwareumgebung f\"ur die
Entwicklung von Projekten --- und einem Steckmodul. Das Steckmodul wird in die
Steckleiste des Dev-Boards befestigt. Der Grafik- wie auch der Mikroporzessor
sitzen auf dem Steckmodul. Somit kann nach Entwicklung und Testen das Steckmodul
unmittelbar in das Produktivsystem integriert werden; sprich, es kann auf die
Entwicklerplatine im Endprodukt verzichtet werden. Eine gute Einf\"uhrung ist auf
\href{https://elinux.org/Jetson_Nano}{dieser} Internequelle zu sehen.

\begin{figure}[!htb]
  \centering
  \subfloat[]{\includegraphics[width=0.4\linewidth]{420/JetsonNanoKitAndComputeModule.png}}
  \qquad
  \subfloat[]{\includegraphics[width=0.4\linewidth]{420/JetsonSchematic.png}}
  \caption{\label{fig:Jet_Schema}Developement-Board mit Steckmodul (a) und Schema (b)}
\end{figure}

\autoref{fig:SysOverview} zeigt, wie der Jetson Nano im Gesamtprojekt eingesetzt
wird. Im System gibt es vier wesentliche Komponenten:

\begin{figure}[!htb]
  \includegraphics[width=0.75\linewidth]{420/SystemOverview.jpeg}
  \caption{\label{fig:SysOverview}Alle Hardwarekomponenten des Systems}
\end{figure}

\begin{itemize}
  \item Raspberry Pie --- Zentrale Steuereinheit des Systems
  \item Jetson Nano --- Das ``Auge'' des Systems
  \item Arduino --- Auswertung von Sensoren und Stellglied von Aktoren
  \item Vesc Motorcontroller --- Stellglied f\"ur den BLDC Motor
\end{itemize}

Alle Hauptkomponenten sind mit dem \emph{CAN}-Bussystem verbunden --- siehe
\autoref{fig:SysOverview}. Hier\"uber wird die Kommunikation abgewickelt. Der
Jetson nimmt \"uber ein Kameramodul Bilder der Umgebung auf. Intern werden die
aufgenommen Bilder einem Neuronalen Netzwerk \"ubergeben, das das Bild auf
interessierende Objekte untersucht. Hier sind die interessierenden Objekte
Fahrzeuge. Und zwar nur Fahrzeuge als solches, hei{\ss}t, es wird nicht weiter
zwischen verschiedene Fahrzeugarten unterschieden. Die Objekterkennung ist somit
bin\"arer Natur. Wurde ein Fahrzeug erkannt, wird eine Nachricht \"uber das
Bussystem verschickt. Es ist Aufgabe des Can-Protokolls, die Nachricht dem
richtigen Adressaten zu \"ubergeben. Hier ist der richtige Adressat das
Raspberry-Modul (Raspberry Pi). Dort wird entschieden, was mit den eingehenden
Informationen geschehen soll.




\section{Software-Installation}

Die Softwareinstallation wird detailiert auf der Nvidia Homepage
beschrieben~\cite{nvidiaJetson}. Deswegen hier nur ein paar Punkte, die
aufgefallen sind und zu erw\"ahnen sich lohnen:

\begin{itemize}
  \item Jetpack
        \begin{itemize}
          \item Aktuellste Installation auf SD Card Image
          \item SD Card Image von \emph{Getting Started with Jetson Nano}
          herunterladen
          \item Gibt auch andere Quellen, aber dort nicht garantiert, dass
          \emph{JetPack} und Abh\"angigkeiten installiert werden
  \end{itemize}

  \item SD Karte manchmal nicht lesbar gewesen
  \begin{itemize}
    \item Staubeinschluss
    \item Wie bei Nintendo 64 oder Gameboy
    \begin{itemize}
      \item SD Karte entfehrnen und ``pusten'' hilft
    \end{itemize}
  \end{itemize}

  \item Starten im ``Headless'' Mode
  \begin{itemize}
    \item ben\"otigt IP Adresse
    \item mit Befehl \verb+$ ipconfig+ im Jetson zu bekommen
  \end{itemize}
\end{itemize}



\section{\label{sec:ordner-struktur}Ordner Struktur}

Es existieren zwei Hauptordnerstrukturen:

%% ToDo
\begin{itemize}
  \item <Detector>
  \item <Hauptprogramm>
\end{itemize}

Beide liegen im Home-Verzeichnis des Users \verb+</home/<user>/>+, wobei
\verb+<user>+ in diesem Fall \verb+jetson+ ist.\\

\emph{<Detector>}: Im der ersten Struktur liegt der von Matlab generierte Code
und das Kompilat (Statische Library). Jedes mal, wenn der Anwender am Host PC in
Matlab einen neuen Algorithmus definiert und \"ubersetzen l\"asst, diesen
anschliessend auf das Zielsystem \"ubertr\"agt, finden sich die generierten Files
und die kompilerte Datei in dieser Ordnerstruktur.

Matlab erstellt eine tiefe Struktur, hei{\ss}t: sehr viele Unterorder und
Verzweigungen. Aber s\"amtlicher Code und Kompilate finden sich dort.

\textbf{Wichtig!!!}: Auch wenn sp\"ater statische Library in anderes Programm ---
anderer Ausf\"uhrungsprozess --- eingebunden wird, liegt das YoLo Netzwerk in
dieser Struktur und ist somit eine \textbf{Abh\"angikeit}. Die Ordnerstruktur
darf \textbf{nicht} gel\"oscht oder ver\"andert werden. Die statische Library
verwenden absolute Pfade.\\

\emph{<Hauptprogramm>}: Dort sind wiederum drei Haupt-Unter-Verzeichnisse
angedacht:
\begin{itemize}
  \item Detector
  \item Filter\_1
  \item CAN\_Dispatcher
\end{itemize}

Jeder dieser Unterverzeichnisse definiert ein seperates Programm, das jeweils
einen eigenen Prozess startet.

\emph{Detector}: Das ist ein in Cuda geschriebenes Programm, das die von Matlab
generierte statische Library einbindet und autark auf der Zielhardware nach dem
Kompilierungsvorgang (NVidia Cuda Compiler --- NVCC) ausf\"uhrbar ist. Vorteil
dieser Vorgehensweise:

\begin{itemize}
  \item Host PC zum Starten des Algorithmus nicht mehr n\"otig
  \begin{itemize}
    \item Statische Library in unabh\"angiges Programm (sp\"aterer Prozess)
          eingebunden
  \end{itemize}

  \item Anwendungsprogrammierer kann beliebige weitere Funktionalit\"aten dem
  Programm hinzuf\"ugen
  \begin{itemize}
    \item Kommandozeilen Parser
    \item Individuelle Ausgabe
    \begin{itemize}
      \item Visuellen Modus
      \item Ausgabe File Descriptor
      \item Bit Stream
      \item usw \dots
    \end{itemize}
  \end{itemize}
\end{itemize}

Nachteilig zu erw\"ahnen ist: Programmierer sollte sich mit CUDA Syntax
auskennen. Aber oft nicht so grosses Problem, da Schnittmenge mit C++ respektive
C Syntax vorhanden. Dennoch ist erstrebenswert: so wenig wie m\"oglich in CUDA
Code zu arbeiten. Deswegen Aufteilung in weitere Programme nach Motto: viele
kleine Programme, die nur \emph{eine} Aufgabe haben, aber diese gut und
effizient umsetzen.\\

Makefile f\"ur den Kompaliervorgang im Projekt hinterlegt und kann mit
\verb+$ make+ Befehl gestartet werden.\\

\emph{Filter}: Die \"Ubertragung der Information (Objekt erkannt oder nicht) ist
als Bit-Stream \"uber die Standartausgabe definiert. Da oben erw\"ahnt, ein Ziel
ist, so wenig wie m\"oglich in CUDA zu Programmieren --- sehr lange Compile-Time,
sehr viel Abh\"angikeiten, kompliziertes Make-File ---, werden weitere
Manipulationen in einem getrennten Programm umgesetzt \emph{Filter}. Der Filter
ist in C++ geschrieben und bereitet die Versendung der Informationen \"uber CAN
vor. Eine weitere Bearbeitung der Daten k\"onnte wie folgt ausehen:\\

Es werden nur weitere Nachrichten an Busteilnehmer gesendet, wenn signifikante
\"Anderungen in der Objekterkennung vorliegen. Bspw.\ Objekt (Fahrzeug) wurde
erkannt und Information \"uber Bus gesendet. Es werden in der Sekunde mehrere
Bilder aufgenommen und auf erkannte oder nicht erkannte Objekte \"uberpr\"uft. Es
gibt jetz zwei M\"oglichkeiten: Es kann immer eine Nachricht versendet werden,
wenn Objekt erkannt --- unter Umst\"anden viele Nachrichten pro Sekunden \"uber
Bus --- oder es wird eine Initialnachricht versendet: Signalisierung Objekt
erstamlig erkannt und weitere nur, wenn sich bspw.\ Entfehrnung oder
N\"aherungsgeschwindigkeit signifikant \"andern. Nachteil der ersten M\"oglichkeit
ist, dass Bus mit Nachriten ``\"uberschwemmt'' wird, aber aus den vielen
Nachrichten sich keine neue Erkenntnis generieren lassen. Dieser Nachteil wird
in der zweiten M\"oglichkeit versucht zu umgehen. Dort werden nur weitere
Nachrichten versendet, wenn es wesentliche \"Anderungen gibt --- hohe
N\"aherungsgeschwindigkeit von erkanntem Fahrzeug, \ldots.\\

\emph{CAN\_Dispatcher}: Im Projekt wurde das \emph{Hauptprogramm} und der
\emph{Filter} implementiert. Die entg\"ultige Kommunikation \"uber CAN Bus blieb
aus. Folgearbeiten k\"onnen mit einer beliebigen anderen Sprache --- bspw.\
Python, C, Rust, \dots --- durchgef\"uhrt werden. Nvidia stellt bspw.\ ein Python
Interface f\"ur die GPIO bereit. Es ist dementsprechend zu pr\"ufen, ob ein
Interface f\"ur SPI Controller existiert. Der Jetson hat kein eigenen \ac{CAN}
Controller, deswegen \ac{CAN} Kommunikation nur \"uber SPI m\"oglich.\\

\textbf{Zusammengefasst}\\

Die komplette Bearbeitung l\"auft in drei getrennten Prozessen ab. Eine
unidirektionale Kommunikation ist notwendig. Die Informationen von ``tiefer''
liegenden Prozessen m\"ussen an den dar\"uberliegenden Prozess weitergegeben
werden. Erw\"ahnt wurde, dass als Ausgang ein Bit-Strom \"uber Standart Ausgabe
definiert wurde. Da auf dem Jetson ein Linux Betriebssystem ausgef\"uhrt wird,
kann die Umsetzung der \emph{Inter-Prozess-Kommunikation} dem Betriebssystem
\"ubergeben werden. Als Mechanismus werden daf\"ur Pipes verwendet.

\begin{itemize}
  \item \verb+$ <Hauptprogramm> | <Filter_1> | <CAN_Dispatcher>+
\end{itemize}

Der senkrechte Balken signalisiert dem Betriebssystem, dass ein Kommunikationskanal von Prozess 1 zu Prozess 2 gebildet werden soll. Die gesamte Ordnerstrukture ist wie folgt in \autoref{fig:directory-structure} gezeigt umgesetzt.

\begin{figure}
  \centering
  \subfloat[]{\includegraphics[width=0.4\linewidth]{420/dir-structure-voodo.png}}
  \qquad
  \subfloat[]{\includegraphics[scale=0.25]{420/dir-cnn-yolo.png}}
  \caption{\label{fig:directory-structure}(a) Voodo Code: Dort sind s\"amtlchen Prozesse definiert und werden
    von dort ausgef\"uhrt (Bash-Skript), (b) Yolo Netzwerk: Viele
    Unterverzeichnisse von Matlab generiert}
\end{figure}
