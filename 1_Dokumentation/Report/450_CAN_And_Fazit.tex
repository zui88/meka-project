\chapter{\label{cha:faz}Fazit}

Es wird ein Ueberblick ueber die \ac{CAN} Versendung gegeben. Danach wird ein
kurzer Rueckblick gegeben, was im Projekt umgesetzt wurde. Am Ende werden die
Punkte angesprochen, die noch offen sind oder im Laufe der Arbeit aufgefallen
sind.




\section{\label{sec:can-transmission}CAN Transmission}

In einem \ac{CAN} Netzwerk teilen sich die einzelnen Teilnehmer den gesamten Bus
--- \autoref{fig:can-network} (a). Ein Teilnehmer wird als \ac{CAN}-Node
bezeichnet.

\begin{figure}[!htb]
  \centering
  \subfloat[]{\includegraphics[width=0.4\linewidth]{450/can_overview.png}}
  \qquad
  \subfloat[]{\includegraphics[width=0.4\linewidth]{450/can_transceiver.png}}
  \caption{\label{fig:can-network}\ac{CAN} Netzwerk; (a): Netzwerk Overview (b):
    Konkrete Umsetzung mit SPI/CAN Controller}
\end{figure}

Im autonomen Fahren Projekt kommunizieren die einzelnen Teile (Jetson Nano,
Raspberry Pie, Arduino Due und VESC Motor-Controller) ueber \ac{CAN}. Deshalb
ist es letztendlich das Ziel, die Information ueber erkannte Objekte den anderen
Teilnehmern --- konkret: Raspberry Pie --- zu informieren.

Der Jetson Nano besitzt keinen eigenen \ac{CAN}-Controller. Die Kommunikation
muss deshalb ueber Umwegen realisiert werden. Als Baustein fuer die Realisierung
SPI nach \ac{CAN} gibt es extra Zusatzhardware, die zwischen Main Controller
(SPI) und \ac{CAN}-Transceiver zwischengeschalten wird. Beispielhafte Umsetzung
mit einem konkreten Baustein \emph{2510} von Microchip ist in
\autoref{fig:can-network} (b) zu sehen. Die \ac{CAN}-Node beinhaltet jetzt den
Main Controller (Jetson Nano), SPI-To-CAN Baustein und den
\ac{CAN}-Transceiver.\\


Die \ac{CAN} Kommunikation wird ueber den SPI-Controller des Jetson Nano
``angestossen''. Die User-Software muss als das Interface des SPI-Controllers
verwenden.

Im Linux-Betriebssystem (Jetson Nano: Ubuntu) kann nicht direkt auf die
unterliegende Hardware zugegriffen werden. Der Zugriff erfolgt ueber
Treibermodule. Diese muessen vor Verwendung geladen werden, wie in
\autoref{fig:hardware-dienstverteiler} dargestellt ist.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\linewidth]{450/linux_dienstverteiler.png}
  \caption{\label{fig:hardware-dienstverteiler}Hardware Dienstverteiler;
    Hardwarezugriff erfolgt nur ueber Kernelmodule. Diese muessen davor
    geladen.}
\end{figure}

Was anfangs zu pruefen ist, ob schon Module verfuegbar sind, bspw.\ von
NVIDIA, die den Zugriff auf den SPI-Controller bereitstellen.




\section{\label{sec:zusammenfassung}Zusammenfassung}

Es wurde einen Algorithmus fuer die Objekterkennung in Matlab geschrieben. Der
Algorithmus verwendet ein \ac{CNN} (YoLo-Variante) als Abhaengigkeit. Das
\ac{CNN} uebernimmt die Objekterkennung und wurde von Vorgaengerarbeiten
bereitgestellt.

Der Algorithmus wurde als statische CUDA-Library auf dem Zielsystem (Jetson
Nano) kompiliert. Die Library wurde dann in einem getrennten Programm als
Abhaengigkeit eingebunden. Diese Vorangehensweise, Matlab Algorithmus als
statische Library zu kompilieren und im Zielsystem als statische Abhaengigkeit
einzubinden, bietet den Vroteil:

\begin{itemize}
  \item Aenderungen im Objekterkennungsprozess sind unabhaengig vom Host-PC
  \begin{itemize}
    \item Auf Host-PC wurde der Algorithmus in der Matlab-IDE erstellt
    \item Somit entfallen langwierige Uebertragungs- und Kompilierungsprozesse, -/zeiten
    \begin{itemize}
      \item Uebertragung von Matlab-Code muss via LAN uebertragen werden
      \item Starten von ``geschlossenen'' Matlabalgorithmen werden von der Matlab-IDE im Host-PC ``angestossen''
    \end{itemize}
  \end{itemize}
  \item Das Starten von Algorithmen kann automatisch ueber ein Skript ``angestossen'' werden
\end{itemize}

Es wurde eine Verarbeitungspipeline vorgestellt. Der Objekterkennungsprozess
ermittelt Objekte in den Liveaufnahmen. Weitere ``Filterungen'' werden in
anderen, getrennten Prozessen durchgefuehrt. Bspw.\ wurde eine Idee vorgestellt,
nicht fuer jeden aufgenommenen Frame immer das selbe erkannte Objekt zu
uebertragen, dass nur unter bestimmten Bedingungen neue Nachrichten fuer das
selbe Objekt uebertragen werden.

Es wurde weiter ausgefuehrt, dass andere Algorithmen die Pipeline einfach
erweitern, oder andere entfehrnt werden koennen. Der letzte Prozess der
Verarbeitungspipeline ist fuer die Versendung der entguehltigen Nachrichten
vorgesehen. Allgemein koennen weitere Prozesse der Pipeline in beliebigen
Sprachen geschrieben werden. So kann auch der letzte Prozess, der die Nachricht
schlussendlich ueber \ac{CAN} versendet, bspw.\ in Python geschrieben werden.
Von NVIDIA sind zahlreiche Skripte und Libraries in Python bereitgestellt.

Zuletzt ist erlaeutert worden, wie die \ac{CAN} Kommunikation konkret in Hardware umgesetzt werden kann.




\section{\label{sec:ausblick}Ausblick}

\begin{itemize}
  \item Unterliegendes \ac{CNN} von binaere Erkennung von Klassen auf Erkennung
        mehrerer Klassen --- nicht nur Klasse von Auto auf bspw.\ Auto, LKW, Fahrrad, Fussgaenger, \dots
  \item Untersuchung Kuehlsystem auf Systemstabilitaet
  \item Umsetzung \ac{CAN} Kommunikation
\end{itemize}
