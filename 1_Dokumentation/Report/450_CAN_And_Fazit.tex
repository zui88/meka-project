\chapter{\label{cha:faz}Fazit}

Es wird ein \"Uberblick \"uber die \ac{CAN} Versendung gegeben. Danach wird ein
kurzer R\"uckblick gegeben, was im Projekt umgesetzt wurde. Am Ende werden die
Punkte angesprochen, die noch offen sind oder im Laufe der Arbeit aufgefallen
sind.




\section{\label{sec:can-transmission}CAN Transmission}

In einem \ac{CAN} Netzwerk teilen sich die einzelnen Teilnehmer den gesamten Bus
--- \autoref{fig:can-network} (a). Ein Teilnehmer wird als \ac{CAN}-Node
bezeichnet.

\begin{figure}[!htb]
  \centering
  \subfloat[]{\includegraphics[width=0.4\linewidth]{450/can_overview.png}}
  \qquad
  \subfloat[]{\includegraphics[width=0.4\linewidth]{450/can_transceiver.png}}
  \caption{\label{fig:can-network}\ac{CAN} Netzwerk; (a): Netzwerk Overview (b):
    Konkrete Umsetzung mit SPI/CAN Controller}
\end{figure}

Im autonomen Fahren Projekt kommunizieren die einzelnen Teile (Jetson Nano,
Raspberry Pie, Arduino Due und VESC Motor-Controller) \"uber \ac{CAN}. Deshalb
ist es letztendlich das Ziel, die Information \"uber erkannte Objekte den anderen
Teilnehmern --- konkret: Raspberry Pie --- zu \"ubergeben.

Der Jetson Nano besitzt keinen eigenen \ac{CAN}-Controller. Die Kommunikation
muss deshalb \"uber Umwegen realisiert werden. Als Baustein f\"ur die Realisierung
SPI nach \ac{CAN} gibt es extra Zusatzhardware, die zwischen Main Controller
(SPI) und \ac{CAN}-Transceiver zwischengeschalten wird. Beispielhafte Umsetzung
mit einem konkreten Baustein \emph{2510} von Microchip ist in
\autoref{fig:can-network} (b) zu sehen. Die \ac{CAN}-Node beinhaltet jetzt den
Main Controller (Jetson Nano), SPI-To-CAN Baustein und den
\ac{CAN}-Transceiver.\\


Die \ac{CAN} Kommunikation wird \"uber den SPI-Controller des Jetson Nano
``angestossen''. Die User-Software muss als Interface den SPI-Controller
verwenden.

Im Linux-Betriebssystem (Jetson Nano: Ubuntu) kann nicht direkt auf die
unterliegende Hardware zugegriffen werden. Der Zugriff erfolgt \"uber
Treibermodule. Diese m\"ussen vor Verwendung geladen werden, wie in
\autoref{fig:hardware-dienstverteiler} dargestellt ist.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\linewidth]{450/linux_dienstverteiler.png}
  \caption{\label{fig:hardware-dienstverteiler}Hardware Dienstverteiler;
    Hardwarezugriff erfolgt nur \"uber Kernelmodule. Die Kernelmodule m\"ussen
    davor
    geladen werden.}
\end{figure}

Was anfangs zu pr\"ufen ist, ob schon Module verf\"ugbar sind, bspw.\ von
NVIDIA, die den Zugriff auf den SPI-Controller bereitstellen.




\section{\label{sec:zusammenfassung}Zusammenfassung}

Es wurde einen Algorithmus f\"ur die Objekterkennung in Matlab geschrieben. Der
Algorithmus verwendet ein \ac{CNN} (YoLo-Variante) als Abh\"angigkeit. Das
\ac{CNN} \"ubernimmt die Objekterkennung und wurde von Vorg\"angerarbeiten
bereitgestellt.

Der Algorithmus wurde als statische CUDA-Library auf dem Zielsystem (Jetson
Nano) kompiliert. Die Library wurde dann in einem getrennten Programm als
Abh\"angigkeit eingebunden. Diese Vorangehensweise, Matlab Algorithmus als
statische Library zu kompilieren und im Zielsystem als statische Abh\"angigkeit
einzubinden, bietet den Vroteil:

\begin{itemize}
  \item \"Anderungen im Objekterkennungsprozess sind unabh\"angig vom Host-PC
  \begin{itemize}
    \item Auf Host-PC wurde der Algorithmus in der Matlab-IDE erstellt
    \item Somit entfallen langwierige \"Ubertragungs- und Kompilierungsprozesse, -/zeiten
    \begin{itemize}
      \item \"Ubertragung von Matlab-Code muss via LAN \"ubertragen werden
      \item Starten von ``geschlossenen'' Matlabalgorithmen werden von der Matlab-IDE im Host-PC ``angestossen''
    \end{itemize}
  \end{itemize}
  \item Das Starten von Algorithmen kann automatisch \"uber ein Skript ``angestossen'' werden
\end{itemize}

Es wurde eine Verarbeitungspipeline vorgestellt. Der Objekterkennungsprozess
ermittelt Objekte in den Liveaufnahmen. Weitere ``Filterungen'' werden in
anderen, getrennten Prozessen durchgef\"uhrt. Bspw.\ wurde eine Idee vorgestellt,
nicht f\"ur jeden aufgenommenen Frame immer das selbe erkannte Objekt zu''
\"ubertragen, dass nur unter bestimmten Bedingungen neue Nachrichten f\"ur das
selbe Objekt \"ubertragen werden.

Es wurde weiter ausgef\"uhrt, dass andere Algorithmen die Pipeline einfach
erweitern, oder andere entfehrnt werden k\"onnen. Der letzte Prozess der
Verarbeitungspipeline ist f\"ur die Versendung der entg\"uhltigen Nachrichten
vorgesehen. Allgemein k\"onnen weitere Prozesse der Pipeline in beliebigen
Sprachen geschrieben werden. So kann auch der letzte Prozess, der die Nachricht
schlussendlich \"uber \ac{CAN} versendet, bspw.\ in Python geschrieben werden.
Von NVIDIA sind zahlreiche Skripte und Libraries in Python bereitgestellt.

Zuletzt ist erl\"autert worden, wie die \ac{CAN} Kommunikation konkret in Hardware umgesetzt werden kann.




\section{\label{sec:ausblick}Ausblick}

\begin{itemize}
  \item Unterliegendes \ac{CNN} von bin\"are Erkennung von Klassen auf Erkennung
        mehrerer Klassen, bspw.\ Auto, LKW, Fahrrad, Fu{\ss}g\"anger, \ldots
  \item Algorithmus bereitstellen, der mehr als nur ein Objekt im Frame erkennt
        und diese mehreren Objekte entsprechend in weiteren Algorithmen
        behandeln (Filter in Bearbeitungspipeline modifizieren, weitere
        erstellen, \ldots)
  \item Untersuchung K\"uhlsystem auf Systemstabilit\"at
  \item Umsetzung \ac{CAN} Kommunikation
\end{itemize}
