%===============================================================================
\chapter{Deployment auf die Hardware}\label{Kap:Deploy}
%===============================================================================
Nachdem nun unterschiedliche Netzwerke für verschiedene Anwendungen erstellt, trainiert und evaluiert werden können, kann nun mit einem Deployment auf die Zielhardware, einen Raspberry Pi begonnen werden. Dieses Vorgehen soll nun nachfolgend genauer erläutert werden.

\section{Hardware Support Packagge}
Um aus MATLAB eine Verbindung zu einem Raspberry Pi aufzubauen und Code zur Ausführung bringen zu können, muss zuerst das MATLAB Hardware Support Package installiert werden.%\textcolor{red}{KMT hier detaillierte anleitung geben(welches Packet...)}
 
Dieses Package ermöglicht die Kommunikation mit der Hardware des Raspberry Pi per Fernzugriff von einem Computer aus, auf welchem MATLAB ausgeführt wird. Es beinhaltet zusätzlich ein Command-Line-interface für den Zugriff auf E/A-Peripheriegeräte und die Kommunikationsschnittstellen des Pi, worüber diese direkt angesprochen und beispielsweise Daten vom den GPIOs gelesen oder Signale ausgegeben werden können.

\section{Code zur Objekterkennung}
Zum Deployment wurde eine umfassende Funktion inklusive einer Parameterermittlung für nachfolgende Benchmark-Tests erstellt. Die Kernpunkte dieser Funktion werden nachfolgend kurz erläutert.
Zuerst muss ein Handle für ein Raspi-Objekt erstellt werden, hier \textbf{raspiObj} genannt.
%	\begin{tiny}
		\begin{matlabcode}
			raspiObj = raspi();
		\end{matlabcode}
%	\end{tiny}
Hierbei stellt MATLAB eine TCP/IP Verbindung zu einem auf dem Raspberry laufenden Server her, wobei einige Parameter des Raspi-Objekts konfiguriert werden. Dies beinhaltet beispielsweise Informationen zur verwendeten Hardware, den verfügbaren Peripheriegeräten, sowie die IP-Adresse und den Host-Namen des Raspberry.\\
Hiernach kann eine an den Pi angeschlossene Kamera direkt angesprochen und verwendet werden, indem nachfolgend eine Instanz der ''cameraboard''-Klasse gebildet wird. Hierbei kann die gewünschte Auflösung ausgewählt werden. Diese wird bei späteren Benchmark-Test (siehe ref) noch von ausschlaggebender Bedeutung sein wird. Die Aufnahme eines Bildes erfolgt mittels der ''snapshot()''-Funktion.

	\begin{matlabcode}
		cam = cameraboard(raspiObj,'Resolution','1280x720')
		%Capture image from webcam
		img = snapshot(cam);
	\end{matlabcode}

Um ein, mit vorgehend beschriebenen Framework erstelltes, KNN zu laden, muss auf nachfolgende Funktion des Coders zurückgegriffen werden. Hierbei wird zusätzlich die Bildergröße mit der das KNN arbeitet (''inputSize'')spezifiziert.
 
	\begin{matlabcode}
	yolov2Obj = coder.loadDeepLearningNetwork('AutoDetektor13-Jun-2020.mat');
	inputSize  = [128,128,3];
	\end{matlabcode}
 
Die aufgenommenen, auf die ''inputSize'' des Netzes skalierten Bilder werden nun anhand der Funktion \textbf{detect()} durch das KNN analysiert und die erkannten Label einschließlich der zugehörigen Scores und Bounding-Boxes gespeichert. 

	\begin{matlabcode}
	[bboxes,scores,labels] = yolov2Obj.detect(imgSizeAdjusted,'Threshold',0.5);
	\end{matlabcode}

Hernach wird das Bild wieder auf die Ausgangsgröße skaliert, um eine detaillierte und Format-füllende Displayausgabe zu garantieren. 
	\begin{matlabcode}
		img = insertShape(img,'Rectangle',bboxes,'LineWidth',1);
		img = insertText(img,[bboxes(:,1),bboxes(:,2)],scores);
	\end{matlabcode}

Nachdem auch die Bounding-Boxes skaliert wurden. Wird das Bild  nun durch die detektierten Bounding-Boxes und Scores erweitert und mit der Funktion \textbf{displayImage()} auf dem Bildschirm ausgegeben. Außerdem wird in einem Fenster die Dauer der Bildaufnahme und die Rechendauer des KNN-basierten Detektors ausgegeben.

	\begin{matlabcode}
	displayImage(raspiObj,img,'Title',textToDisplay); 
	\end{matlabcode}

Um für das nachfolgende Benchmark-Testing reproduzierbare, aussagekräftige Kenngrößen zu ermitteln wird bei jedem Analysevorgang die Aufnahmedauer zur Erfassung des Bildes, die Rechenzeit des KNN, sowie dessen Ergebnisse protokolliert. Hieraus werden folgende Kenngrößen ermittelt:
\begin{itemize}
	\item{ averageDetectionTime: }Durchschnittliche Analysedauer durch KNN.
	\item{ averageCaptureTime: }Durchschnittliche Dauer zur Erfassung und Übertragung eines Bildes.
	\item{ Max/Min DetectionTime: } (zur Beurteilung der Streuung ).%\textcolor{color}{correkte definition bitte (weiss ich nicht)}
	\item{ Max/Min CaptureTime: } (zur Beurteilung der Streuung )%\textcolor{color}{correkte definition bitte (weiss ich nicht)}
\end{itemize}

\subsection{Ausführung auf Pi über MATLAB als Schnittstelle}
Die erstellte Funktion kann nun zu Testzwecken direkt aus MATLAB mittels ''run'' ausgeführt werden. Hierbei wird nach und nach jede Zeile von MATLAB aus über eine Remoteverbindung zum Raspberry zur Ausführung gebracht. Die hierbei erstellten Variablen werden im Matlab-Workspace auf dem Rechner abgelegt. Die Textausgaben werden im Matlab-Kommando-Fenster und die Bilder in einer Matlab Figure angezeigt. Es wird hierbei also keine eigenständige Funktion ausgelagert, sondern der Raspberry dient lediglich als Interface zur Aufnahme der Bilder. Hierdurch kann jedoch sichergestellt werden, dass die Funktionen wie erwartet mit der Hardware zusammenarbeiten. Falls nicht können Probleme mit Peripheriegeräten hierbei deutlich einfacher ge-debugged werden, als dies bei deploytem Maschinencode möglich ist. \\
Zu beachten ist hierbei, dass nur bestimmte MATLAB Funktionen zur Erzeugung von Maschinencode für den Raspberry Pi geeignet sind. Um deren Kompatibilität zu überprüfen kann nach der Funktions-Deklarierung die Kompiler-Anweisung \textbf{\%\# codegen} eingefügt werden, sodass automatisch mithilfe des MATLAB Code Analyzers deren Verwendbarkeit verifiziert werden kann. Hierbei wird der Code bereits während der Eingabe geprüft und somit Kompilierfehler minimiert. Anhand eines Anzeigefeldes rechts oben im Editor kann man hierbei erkennen, ob die Funktion Fehler oder Warnungen enthält. 
\subsection{Deployment als Stand-Alone-Function} 
Um jedoch den gesamten Berechnungsprozess und die Datenverarbeitung auf dem Raspberry Pi ausführen zu können, muss dieser in Maschinencode übersetzt und auf dem Raspberry zur Ausführung gebracht werden. Nachfolgend soll daher aus den vorhandenen MATLAB-Funktionen C++ -Code generiert und dieser in Maschinencode in Form einer ausführbaren .elf-Datei übersetzt werden. Um diese Aufgabe zu bewältigen wurde abermals eine Funktion geschrieben, welcher eine beliebige Funktion in Form des Dateinamens als String übergeben wird und die nötigen Schritte zur Erzeugung des Maschinencodes einleitet. \\
Die wichtigsten Schritte hierbei sollen nun eingehender erläutert werden.\\
Zuerst muss von MATLAB wie bereits erläutert eine Remote-Verbindung zum Pi aufgebaut werden. Da immer nur eine Verbindung zum Raspberry bestehen kann, muss zuerst eine eventuell bestehende Verbindung durch Löschen des raspi-Objekts abgebaut werden. Hiernach wird die Zielhardware für das Deployment des Codes als ''Raspberry Pi'' festgelegt.C++ wird als die auf dem Zieltareg verwendete Hochsprache gesetzt.
	\begin{matlabcode}
	%eventuell vorhandenes Raspi-Object löschen
	clear r;
	%neues Raspi-Object erstellen 
	r = raspi;
	
	%Parameter zur Code-Generierung:
	%Zielhardware
	board = targetHardware('Raspberry Pi');
	%Zielsprache
	board.CoderConfig.TargetLang = 'C++';
	\end{matlabcode}
Da die vorliegende Funktion Methoden der Deep-Learning-Toolbox verwendet, muss zusätzlich die Coder-Konfiguration für Deep-Leraning und den Pi angepasst werden:\\
 Zuerst wird die ''CoderConfig'' auf die Zielhardware des Pi angepasst, indem auf die ''Arm-Compute-Library'' Funktionen zurückgegriffen werden kann. Hierbei wurde, die zu diesem Zeitpunkt aktuellste Version der Architektur ('armv7') und der ''Compute-Library'' ('19.05') ausgewählt. 
	\begin{matlabcode}
	%Coder-Configuartion für Pi anpassen
	dlcfg = coder.DeepLearningConfig('arm-compute');
	dlcfg.ArmArchitecture = 'armv7';
	dlcfg.ArmComputeVersion = '19.05';
	board.CoderConfig.DeepLearningConfig = dlcfg
	\end{matlabcode}
Mit folgendem Code kann diese Konfiguration auf das raspiObject angewandt werden.
\begin{small}
\begin{matlabcode}
		%Konfiguration auf Raspi-Object anwenden
	r.system('strings \$ARM_COMPUTELIB/lib/libarm_compute.so |...
	           grep arm_compute_versio | cut -d\  -f 1')	
\end{matlabcode}
\end{small}

Der Kompilations- und Auslagerungsvorgang der eigenständig ausführbaren Funktion erfolgt schließlich mittels der Funktion deploy().Dieser wird die konfigurierte Zielhardware und die Auzuführende Matlaab-Funktion übergeben.
	\begin{matlabcode}
	deploy(board,functionToDeploy)	
	\end{matlabcode}

Diese Funktion lässt sich nun universell auf Funktionen anwenden, welche auf den Raspberry deployed werden sollen. Hierfür muss lediglich die soeben erstelle Funktion \textbf{deployToPi()} aufgerufen werden, welcher der Dateiname der gewünschten Funktion wie nachfolgend dargestellt als String übergeben werden muss. \\
Im folgenden Code ist ein Aufruf dieser Funktion beispielhaft dargestellt.

	\begin{matlabcode}
	deployToPi('raspi_webcam_v014_small_1280_720.m')	
	\end{matlabcode}
\textcolor{red}{ÜBERLEITUNG???} 
HAllO

%EOF